<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <link rel="stylesheet" type="text/css" href="html.css" />
    <title>JAS project users guide</title>
  </head>
  <body class="main">
    <h1>Interactive users guide</h1>

<p>
This document contains some (first) how to and usage 
information for the JAS project.
JAS can be used as any other Java library by adding <code>jas.jar</code> 
to the classpath and creating and using objects from it.
JAS can also be used interactively via the Python Java interpreter 
<code>jython</code>. This is explained in this document.
For an introduction the API see the <a href="design.html">API guide</a>.
Since JAS Version 2.2 there is an enhanced interface which allows 
direct input of algebraic expressions, see <a href="#express">here</a>. 
</p>


<h3>Getting started</h3>

<p>
As first example we will discus how to compute a Groebner base with
<code>jython</code>. The jython script will be placed into a file, e.g.
<a href="examples/getstart.py"><code>getstart.py</code></a>. 
This script file is executed by calling
</p>
<pre>
  jython getstart.py
</pre>
<p>
The script file first imports the desired mathematical classes from the 
<code>jas.py</code> script which does all interfacing to the Java library.
For the Epydoc of it see <a href="doc/jython/index.html" target="jython">here</a>.
</p>
<pre>
  from jas import Ring
  from jas import Ideal
</pre>
<p>
In our case we need <code>Ring</code> to define an appropriate polynomial ring
and <code>Ideal</code> to define sets of polynomials and have methods to 
compute Groebner bases. 
<code>Ring</code> takes a string argument which contains required definitions 
of the polynomial ring: the type of the coefficient ring, the names of 
the used variables and the desired term order.
</p>
<pre>
  r = Ring( "Rat(B,S,T,Z,P,W) L" );
</pre>
<p>
The ring definition is stored in the variable <code>r</code> for later use.
The string <code>"Rat(B,S,T,Z,P,W) L"</code> defines the coefficient ring 
to be the rational numbers <code>Rat</code>,
the polynomial ring consists of the variables <code>B, S, T, Z, P, W</code>
and the term order <code>L</code> means a lexicographic term order.
For some historical reason the term order orders the variables as 
<code>B &lt; S &lt; T &lt; Z &lt; P &lt; W</code> and not the other way. 
I.e. the highest or largest variable is always on the left of the list of
variables not on the right as in some other algebra systems.
With 
</p>
<pre>
  print "Ring: " + str(r);
</pre>
<p>
you can print out the ring definition. 
<code>str(r)</code> is the usual python way of producing string representations
of objects, which in our case calls the respective Java method 
<code>toString()</code> of the JAS ring object. It produces
</p>
<pre>
Ring: BigRational(B, S, T, Z, P, W) INVLEX
</pre>
<p>
i.e. the coefficients are from the jas class <code>BigRational</code>
and the term order is <code>INVLEX</code> 
(<code>INV</code> because the largest variable is on the left).
Next we need to enter the generating polynomials for the ideal. 
We do this in two steps, first define a python string with the polynomials 
and then the creation of the ideal using the ring definition from before 
and the polynomial string.
</p>
<pre>
ps = """
( 
 ( 45 P + 35 S - 165 B - 36 ), 
 ( 35 P + 40 Z + 25 T - 27 S ), 
 ( 15 W + 25 S P + 30 Z - 18 T - 165 B**2 ), 
 ( - 9 W + 15 T P + 20 S Z ), 
 ( P W + 2 T Z - 11 B**3 ), 
 ( 99 W - 11 B S + 3 B**2 ),
 ( B**2 + 33/50 B + 2673/10000 )
) 
""";
</pre>
<p>
The polynomial string can be generated by any means python allows for 
string manipulation. 
In our example we use python multiline strings, which are delimited by 
triple quotes <code>""" ... """</code>.
The list of polynomials is delimited by parenthesis <code>( ... )</code>,
as well as every polynomial is delimited by parenthesis, e.g.
<code>( B**2 + 33/50 B + 2673/10000 )</code>.
The polynomials are separated by commas.
The syntax for polynomials is a sequence of monimals consisting 
of coefficients and terms (as products of powers of variables).
The terms can optionally be written with multiplication sign,  
i.e. <code>25 S P</code> can be written <code>25*S*P</code>. 
Variable names must be delimited by white space or some operator,
i.e. you can not write <code>25 SP</code> because <code>SP</code>
is not a listed variable name in the polynomial ring definition.
Coefficients may not contain white space, i.e. the <code>/</code>
separating the nominator from the denominator may not be surrounded 
by spaces, i.e. writing <code>33 / 50</code> is not allowed.
Powers of variables can be written with <code>**</code> or <code>^</code>,
i.e. the square of <code>B</code> is written as <code>B**2</code>
or <code>B^2</code>.
The ideal is the defined with
</p>
<pre>
  f = Ideal( r, ps );
</pre>
<p>
The ideal is contained the the polynomial ring <code>r</code>
and consists of the polynomials from the string <code>ps</code>.
Ideals can be printed with
</p>
<pre>
  print "Ideal: " + str(f);
</pre>
<p>
In this example it produces the following output.
</p>
<pre>
Ideal: BigRational(B, S, T, Z, P, W) INVLEX
(
( B^2 + 33/50 B + 2673/10000  ),
( 45 P + 35 S - 165 B - 36  ),
( 35 P + 40 Z + 25 T - 27 S ),
( 15 W + 25 S * P + 30 Z - 18 T - 165 B^2 ),
( -9 W + 15 T * P + 20 S * Z ),
( 99 W - 11 B * S + 3 B^2 ),
( P * W + 2 T * Z - 11 B^3 )
)
</pre>
<p>
The polynomial terms are now sorted with respect to the lexicographical 
term order. The highest term is first in a polynomial.
Also the polynomials are sorted with respect to the term order, but
with smallest polynomial first in the list.
Finaly we can go to the computation of the Groebner basis of this ideal.
</p>
<pre>
  g = f.GB();
</pre>
<p>
The ideal <code>f</code> has a method <code>GB()</code> which 
computes the Groebner base. The computed Groebner base is stored
in the variable <code>g</code> which is also an ideal.
It can be printed as the ideal <code>f</code>
</p>
<pre>
  print "Groebner base:", g;
</pre>
<p>
The output first shows the output from calling the <code>GB()</code> method
and the the ideal basis.
</p>
<pre>
sequential executed in 136 ms

Groebner base: BigRational(B, S, T, Z, P, W) INVLEX
(
( B^2 + 33/50 B + 2673/10000  ),
( S - 5/2 B - 9/200  ),
( T - 37/15 B + 27/250  ),
( Z + 49/36 B + 1143/2000  ),
( P - 31/18 B - 153/200  ),
( W + 19/120 B + 1323/20000  )
)
</pre>
<p>I.e. the Groebner base was computed in 135 ms and consists 
of six polynomials. The polynomials are now monic, 
i.e. the leading coefficient is 1 and omitted during print out.
This concludes the getting started section.
</p>


<h3>Overview of jas.py classes and methods</h3>

<p>
The jython interface to the JAS library consists of the 
following jython classes.
For the Epydoc of them see <a href="doc/jython/index.html" target="jython">here</a>.
</p>
<ul>
<li><p><code>Ring</code>, <code>Ideal</code> and <code>ParamIdeal</code> <br />
    define polynomial rings, ideals and ideals over rings with coefficient parameters. 
    <br />
    <code>Ideal</code> has methods for sequential, parallel and distributed 
    Groebner bases computation, for example 
    <code>GB()</code>, <code>isGB()</code>,
    <code>parGB()</code>,  <code>distGB()</code>,  
    <code>NF()</code> and  <code>intersect()</code>.
    <br />
    <code>ParamIdeal</code> has methods for comprehensive  
    Groebner bases computation, for example
    <code>CGB()</code>,  <code>CGBsystem()</code>,  <code>regularGB()</code>,  
    </p>
</li>
<li><p><code>SolvableRing</code> and <code>SolvableIdeal</code> <br />
    define solvable polynomial rings and left, right and two-sided ideals.<br />
    <code>SolvableIdeal</code> has methods for left, right and two-sided
    Groebner bases computation, e.g.
    <code>leftGB()</code>,  <code>rightGB()</code>,  <code>twosidedGB()</code>,  
    <code>intersect()</code>.
    </p>
</li>
<li><p><code>Module</code> and <code>SubModule</code> <br />
    define modules over polynomial rings and sub modules. <br />
    <code>Module</code> has a method for sequential Groebner bases computation, 
    e.g. <code>GB()</code>.  
    </p>
</li>
<li><p><code>SolvableModule</code> and <code>SolvableSubModule</code> <br />
    define modules over solvable polynomial rings and sub modules. <br />
    <code>SolvableModule</code> has methods for left, right and two-sided
    Groebner bases computation, e.g.
    <code>leftGB()</code>,  <code>rightGB()</code>,  <code>twosidedGB()</code>.
    </p>
</li>
</ul>


<h3>Algebraic expressions</h3>

<p><a name="express"></a>Since JAS Version 2.2 there is an enhanced
interface which allows direct input of algebraic expressions.
For example the above example looks as follows.
</p>
<pre>
r = Ring( "Z(B,S,T,Z,P,W) L" );
print "Ring: " + str(r); 

[B,S,T,Z,P,W] = r.gens();

f1 = 45 * P + 35 * S - 165 * B - 36;
f2 = 35 * P + 40 * Z + 25 * T - 27 * S;
f3 = 15 * W + 25 * S * P + 30 * Z - 18 * T - 165 * B**2;
f4 = - 9 * W + 15 * T * P + 20 * S * Z;
f5 = P * W + 2 * T * Z - 11 * B**3;
f6 = 99 * W - 11 *B * S + 3 * B**2;
f7 = 10000 * B**2 + 6600 * B + 2673;

F = [ f1, f2, f3, f4, f5, f6, f7 ];

I = r.ideal( "", list=F );
</pre>
<p>
The definition of the polynomial ring with
<code>r = Ring( "Z(B,S,T,Z,P,W) L" )</code>
is obligatory as before. As above many coefficient rings,
e.g. <code>Z</code>, and term orders, e.g. <code>L</code>, can be selected.
</p>
<p>
New is the setup of a list of generators of the polynomial ring with
<code>[B,S,T,Z,P,W] = r.gens()</code>. The sequence of jython variable names 
<code>B, S, T, Z, P, W</code> should match the sequence of variables as defined 
in the creation of the ring.
A jython variable defined with this idiom then represents a polynomial 
of the respective ring in the respectively named variable.
For example <code>B</code> is the polynomial in ring <code>r</code>
in the variable named <code>'B'</code>.
</p>
<p>
The so defined polynomial generators can the be used to
build (nearly) arbitrary expressions.
For example the polynomial <code>f5</code> is defined by the expression
<code>P * W + 2 * T * Z - 11 * B**3</code>.
Since Python (and jython) has no built-in rational number support, 
only (arbitrary long) integers can be used as numbers.
As a work around we propose to use python tuples or lists 
with 2 entries as rational numbers.
Floating point numbers are truncated to integer. 
For exponentiation one must use the double star <code>**</code> as the 
carret <code>^</code> has a fixed meaning as as bitwise XOR.
Additionally all operators must explicitly be written, 
even between coefficients and variables.
The literal representation of the polynomial expression does not restrict 
the definition of the ring. So the polynomial ring can be defined with 
rational coefficients but Python integers can be used as operands.
If you need to enter rational numbers you must use  
python tuple or list notation (see below) 
or explicitly the JAS class <code>BigRational</code>.
</p>
<p>Continuing with the example, we build a list of polynomials 
with a Python list <code>F = [ f1, f2, f3, f4, f5, f6, f7 ]</code>. 
Finally the ideal is created as usual with the 
<code>ideal</code> method of <code>r</code> as 
<code>I = r.ideal( "", list=F )</code>.
</p>
<p>
When python tuples or lists of integers are used as operands of JAS ring elements
they are interpreted as rational or complex rational numbers. 
For example in the construction of Legendre polynomials a 
rational number <code>r = 1/n</code> appears.
As tuple literal it is written <code>(1,n)</code> and 
as list literal it can be written as <code>[1,n]</code>.
</p>
<pre>
p = (2*n-1) * x * P[n-1] - (n-1) * P[n-2];
r = (1,n); # no rational numbers in python, use tuple notation
p = r * p; 
</pre>
<p>
In the same way complex rational numbers can be written as nested tuples.
For example <code>1/n + 1/2 i</code> can be written as
<code>((1,n),(1,2))</code>. 
If the second list element is omited it is asumed to be one.
In this case it can however not be written as tuple, 
since one nesting level would be removed as expression parenthesis.
If the tuples or lists contain more than 2 elements, the rest is 
silently ignored.
For example <code>1/n</code> as complex number can be written as
<code>[(1,n)]</code> (but not as <code>((1,n))</code>). 
Different nesting levels are allowed, i.e.
<code>((1,n),2)</code> or <code>(0,(1,n))</code> are legal.
</p>
<p>In case the types (nesting levels) of operands do not match, 
for example when adding a rational to a complex number 
(low level) class cast errors will be thrown.
For example in <code>(1,n) + (0,(1,n))</code> the exception 
<code>edu.jas.arith.BigComplex cannot be cast to edu.jas.arith.BigRational</code> 
will be thrown.
</p>
<p>Further examples can be found in the jython files
<a href="examples/polynomial.py" target="jython"><code>polynomial.py</code></a>,
<a href="examples/legendre.py" target="jython"><code>legendre.py</code></a>,
<a href="examples/hermite.py" target="jython"><code>hermite.py</code></a> or
<a href="examples/chebyshev.py" target="jython"><code>chebyshev.py</code></a>.
</p>


<h4>Univariate power series</h4>

<p>Univariate power series can be constructed via 
the <code>SeriesRing</code> class. 
In the following example we create a new power series ring 
<code>pr</code> in the variable <code>y</code> over the rational numbers.
The creation of power series is done in the same way as 
polynomials are created. There are additional methods like 
<code>r.exp()</code> or <code>r.sin()</code> to create the 
exponential power series or the power series for the sinus function.
</p>
<pre>
pr = SeriesRing("Q(y)");
print "pr:", pr;

one = pr.one();
r1 = pr.random(4);
r2 = pr.random(4);

print "one:", one;
print "r1:", r1;
print "r2:", r2;

r4 = r1 * r2 + one;
e = pr.exp();
r5 = r1 * r2 + e;

print "e:", e;
print "r4:", r4;
print "r5:", r5;
</pre>
<p>Once power series are created, for example 
<code>r1, r2, e</code> above, it is possible to use 
arithmetic operators to built expressions of power series like
'<code>r1 * r2 + one</code>' or '<code>r1 * r2 + e</code>'.
</p>
<pre>
pr: BigRational((y))

one: 1  + BigO(y^11)
r1:  - 14/3 * y + 3/5 * y^6 + 1/12 * y^8 + 1/7 * y^10 + BigO(y^11)
r2:  - 9/11  - 11/9 * y - 4/3 * y^4 + 7/9 * y^5 + 3 * y^6 - 3/2 * y^8 + BigO(y^11)

e: 1  + 1 * y + 1/2 * y^2 + 1/6 * y^3 + 1/24 * y^4 + 1/120 * y^5 + 1/720 * y^6 + 1/5040 * y^7 + 1/40320 * y^8 + 1/362880 * y^9 + 1/3628800 * y^10 + BigO(y^11)
r4: 1  + 42/11 * y + 154/27 * y^2 + 56/9 * y^5 - 6119/1485 * y^6 - 221/15 * y^7 - 3/44 * y^8 + 745/108 * y^9 - 353/385 * y^10 + BigO(y^11)
r5: 1  + 53/11 * y + 335/54 * y^2 + 1/6 * y^3 + 1/24 * y^4 + 2243/360 * y^5 - 97871/23760 * y^6 - 14851/1008 * y^7 - 30229/443520 * y^8 + 2503201/362880 * y^9 - 36599029/39916800 * y^10 + BigO(y^11)
</pre>
<p>
It is also possible to create power series by defining a generating function 
or by defining a fixed point with respect to a map between power series. 
</p>
<pre>
def g(a):
    return a+a;
ps1 = pr.create(g);

class coeff( Coefficients ):
    def generate(self,i):
        ...
ps6 = pr.create( clazz=coeff( pr.ring.coFac ) );

class cosmap( PowerSeriesMap ):
    def map(self,ps):
        ...
ps8 = pr.fixPoint( cosmap( pr.ring.coFac ) );
</pre>
<p>More details and further examples can be found in the jython file
<a href="examples/powerseries.py" target="jython"><code>powerseries.py</code></a>.
</p>


<h3>Solvable polynomial rings</h3>

<p>
Solvable polynomial rings are non commutative polynomial rings 
where the non commutativity is expressed by commutator relations.
Commutator relations are stored in a data structure called relation table.
In the definition of a solvable polynomial ring this relation table must be 
defined. E.g the definition for the ring of a Weyl algebra is
</p>
<pre>
Rat(a,b,e1,e2,e3) L
RelationTable
(
 ( e3 ), ( e1 ), ( e1 e3 - e1 ),
 ( e3 ), ( e2 ), ( e2 e3 - e2 )
)
</pre>
<p>
The relation table must be build from triples of (commutative) polynomials.
A triple <code>p1, p2, p3</code> is interpreted as non commutative 
multiplication relation <code>p1 .*. p2 = p3</code>. 
Currently <code>p1</code> and <code>p2</code> must be single term, single variable
polynomials. The term order must be choosen such that 
leadingTerm(<code>p1 p2</code>) equals leadingTerm(<code>p3</code>)
and <code>p1 &gt; p2</code> for each triple.
Polynomial <code>p3</code> must be in commutative form, 
i.e. multiplication operators occuring in it are commutative.
Variables for which there are no commutator relations are assumed to 
commute with each other and with all other variables, 
e.g. the variables <code>a, b</code> in the example.
Polynomials in the generating set of an ideal are also assumed to be 
in commutative form. This will be changed in the future to allow the 
multiplication operator to mean non-commutative multiplication.
</p>

<p>A complete example is contained in the python script 
<a href="examples/solvable.py"><code>solvable.py</code></a>.
Running the script computes a left, right and twosided Groebner base
for the following ideal
</p>
<pre>
(
 ( e1 e3^3 + e2^10 - a ),
 ( e1^3 e2^2 + e3 ),
 ( e3^3 + e3^2 - b )
)
</pre>
<p>The left Groebner base is
</p>
<pre>
(
 ( a ), ( b ),
 ( e1^3 * e2^2 ), ( e2^10 ), ( e3 )
)
</pre>
<p>the twosided Groebner base is
</p>
<pre>
(
 ( a ), ( b ), ( e1 ), ( e2 ), ( e3 )
)
</pre>
<p>and the right Groebner base is
</p>
<pre>
(
 ( a ), ( b ), ( e1 ), ( e2^10 ), ( e3 )
)
</pre>


<p>A module example is in 
<a href="examples/armbruster.py"><code>armbruster.py</code></a> 
and a solvable module example is in
<a href="examples/solvablemodule.py"><code>solvablemodule.py</code></a>.
</p>


<!--
<h3>Some internals of jas.py</h3>
--> 


<!--
<li><p><code></code><code></code>
    </p>
</li>

<pre>
</pre>

<p>
</p>
<pre>
</pre>

<p>
</p>
<pre>
</pre>
-->

<hr />
<address><a href="mailto:kredel@at@rz.uni-mannheim.de">Heinz Kredel</a></address>
<p>
<!-- Created: Sun Feb 19 15:49:14 CET 2006 -->
<!-- hhmts start -->
Last modified: Thu Oct  9 22:56:31 CEST 2008
<!-- hhmts end -->
</p>
<!--p align="right" >
$Id: guide.html 2179 2008-10-09 20:57:16Z kredel $
</p-->
  </body>
</html>
