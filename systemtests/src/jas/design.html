<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <link rel="stylesheet" type="text/css" href="html.css" />
    <title>JAS - API Design</title>
  </head>
  <body class="main">
    <h1>API usage and design overview</h1>

<p>
In ths document we give an overview on the structure 
of the interfaces, classes and packages of JAS.
In the first section we show how to compute Legendre polynomials 
with the JAS API.
In the next three sections we focus on the structure 
of the required types and the creation of the corresponding objects.
In the following three sections we focus on the functional aspects of 
the types, i.e. their constructors and methods.
For a discussion of other design alternatives see
the <a href="problems.html">problems</a> document.
</p>


<h2>1. Getting started</h2>


<h3>1.1. Computation of the Legendre polynomials</h3>

At first we present an example for the usage of the JAS API
with the computation of the Legendre polynomials.
The Legendre polynomials can be defined by the following recursion
<ul>
<li>P[0](x) = 1
</li>
<li>P[1](x) = x
</li>
<li>P[n](x) = 1/n ( (2n-1) x P[n-1] - (n-1) P[n-2] ).
</li>
</ul>
The first 10 Legendre polynomials are:
<pre style="background-color: #FFFFF5;">
P[0] = 1 
P[1] = x
P[2] = 3/2 x^2 - 1/2 
P[3] = 5/2 x^3 - 3/2 x
P[4] = 35/8 x^4 - 15/4 x^2 + 3/8 
P[5] = 63/8 x^5 - 35/4 x^3 + 15/8 x
P[6] = 231/16 x^6 - 315/16 x^4 + 105/16 x^2 - 5/16 
P[7] = 429/16 x^7 - 693/16 x^5 + 315/16 x^3 - 35/16 x
P[8] = 6435/128 x^8 - 3003/32 x^6 + 3465/64 x^4 - 315/32 x^2 + 35/128 
P[9] = 12155/128 x^9 - 6435/32 x^7 + 9009/64 x^5 - 1155/32 x^3 + 315/128 x
</pre>

<p>
The polynomials have been computed with the following Java program.
First we need a polynomial ring <code>ring</code> over the rational numbers, 
in one variable <code>"x"</code> and a list <code>P</code> to store the
computed polynomials.
The polynomial factory object itself needs at least a factory for
the creation of coefficients and the number of variables.
Additionally the term order and names for the variables can be
specified. With this information the polynomial ring factory
can be created by 
<code>new GenPolynomialRing &lt;BigRational&gt;(fac,1,var)</code>,
where <code>fac</code> is the coefficient factory,
<code>1</code> is the number of variables, and
<!--<code>to</code> is the term order object and-->
<code>var</code> is an <code>String</code> array of names.
</p>
<pre>
    BigRational fac = new BigRational();
    String[] var = new String[]{ "x" };
    GenPolynomialRing&lt;BigRational&gt; ring
        = new GenPolynomialRing&lt;BigRational&gt;(fac,1,var);

    int n = 10;
    List&lt;GenPolynomial&lt;BigRational&gt;&gt; P 
       = new ArrayList&lt;GenPolynomial&lt;BigRational&gt;&gt;(n);
    GenPolynomial&lt;BigRational&gt; t, one, x, xc;
    BigRational n21, nn;

    one = ring.getONE();
    x   = ring.univariate(0);

    P.add( one );
    P.add( x );
    for ( int i = 2; i &lt; n; i++ ) {
        n21 = new BigRational( 2*i-1 );
        xc = x.multiply( n21 );
        t = xc.multiply( P.get(i-1) );  // (2n-1) x P[n-1]
        nn = new BigRational( i-1 );
        xc = P.get(i-2).multiply( nn ); // (n-1) P[n-2]
        t = t.subtract( xc );
        nn = new BigRational(1,i);      
        t = t.multiply( nn );           // 1/n t
        P.add( t );
    }
    for ( int i = 0; i &lt; n; i++ ) {
        System.out.println("P["+i+"] = " + P.get(i).toString(var) );
        System.out.println();
    }
</pre>
<p>
The polynomials for the recursion base are <code>one</code> and <code>x</code>.
Both are generated from the polynomial ring factory
with method <code>ring.getONE()</code> and <code>ring.univariate(0)</code>,
respectively. 
The polynomial <code>(2n-1)x</code> is produced in the for-loop by 
<code>n21 = new BigRational( 2*i-1 );</code> and
<code>xc = x.multiply( n21 );</code>.
The polynomial <code>(n-1) P[n-2]</code> is computed by
<code>nn = new BigRational( i-1 );</code> and
<code>xc = P.get(i-2).multiply( nn )</code>.
Finally we have to multiply the difference of the 
intermediate polynomials by <code>1/i</code> as 
<code>nn = new BigRational( 1, i );</code> and
<code>t = t.multiply( nn )</code>.
Then, in the for-loop, the polynomials <code>P[i]</code> are computed
using the definition, and stored in the list <code>P</code> for further use.
In the last for-loop, the polynomials are printed, producing the
output shown above.
The string representation of the polynomial object can be created,
as expected, by <code>toString()</code>,
or by using names for the variables with <code>toString(var)</code>.
The imports required are
</p>
<pre>
import java.util.ArrayList;
import java.util.List;
import edu.jas.arith.BigRational;
import edu.jas.poly.GenPolynomial;
import edu.jas.poly.GenPolynomialRing;
</pre>
<p>
To use other coefficient rings, one simply changes the
generic type parameter, say, from <code>BigRational</code> to
<code>BigComplex</code> and adjusts the coefficient factory.
The factory would then be created as
<code>c = new BigComplex()</code>, followed by
<code>new GenPolynomialRing&lt;BigComplex&gt; (c,1,var)</code>.
This small example shows that this library can easily be used,
just as any other Java package or library.
</p>
<!--
The string argument of method <code>parse()</code> can be the
TeX-representation of the polynomial,
except that no subscripts may appear.
-->
<p>
In the following sections we describe the 
central classes and interfaces for the polynomial API.
</p>

<h3>1.2. Algebraic structures overview</h3>

<p>
To get an idea of the scope of JAS we summarize 
the implemented algebraic structures and 
of the implemented algebraic algorithms.
</p>

<table border="1" cellpadding="3" summary="JAS AS summary" >
<tr>
<td>class</td>
<td>factory</td>
<td>structure</td>
<td>methods</td>
</tr>

<tr>
<td><code>BigInteger</code></td>
<td>self</td>
<td>ring of arbitrary precision integers,
    a facade for <code>java.math.BigInteger</code>
</td>
<td>arithmetic, gcd, primality test</td>
</tr>

<tr>
<td><code>BigRational</code></td>
<td>self</td>
<td>ring of arbitrary precision rational numbers,
    i.e. fractions of integers,
    with Henrici optimizations for gcds
</td>
<td>arithmetic</td>
</tr>

<tr>
<td><code>ModInteger</code></td>
<td><code>ModIntegerRing</code></td>
<td>ring of integers modulo some fixed (arbitrary precision) integer <code>n</code>,
    if <code>n</code> is a prime number, the ring is a field
</td>
<td>arithmetic, chinese remainder</td>
</tr>

<tr>
<td><code>BigDecimal</code></td>
<td>self</td>
<td>ring of arbitrary precision floating point numbers,
    a facade for <code>java.math.BigDecimal</code>
</td>
<td>arithmetic, <code>compareTo()</code> with given precision</td>
</tr>

<tr>
<td><code>BigComplex</code></td>
<td>self</td>
<td>ring of arbitrary precision complex numbers,
    i.e. pairs of rational numbers
</td>
<td>arithmetic</td>
</tr>

<tr>
<td><code>BigQuaternion</code></td>
<td>self</td>
<td>ring of arbitrary precision quaternion numbers,
    i.e. quadruples of rational numbers
</td>
<td>arithmetic</td>
</tr>

<tr>
<td><code>BigOctonion</code></td>
<td>self</td>
<td>ring of arbitrary precision octonion numbers,
    i.e. implemented as pairs of quaternion numbers
</td>
<td>arithmetic</td>
</tr>

<tr>
<td><code>GenPolynomial</code></td>
<td><code>GenPolynomialRing</code></td>
<td>ring of polynomials in <code>r</code> variables 
    over any implemented coefficient ring
    with respect to any implemented term ordering
</td>
<td>arithmetic, univariate gcd, norms, 
    chinese remainders for coefficients, evaluation</td>
</tr>

<tr>
<td><code>AlgebraicNumber</code></td>
<td><code>AlgebraicNumber- Ring</code></td>
<td>ring of algebraic numbers, represented as 
    univariate polynomials 
    over any implemented coefficient field
</td>
<td>arithmetic
</td>
</tr>

<tr>
<td><code>GenSolvable- Polynomial</code></td>
<td><code>GenSolvable- PolynomialRing</code></td>
<td>ring of non-commutative, solvable polynomials in <code>r</code> variables 
    over any implemented coefficient ring
    with respect to any implemented term ordering
    (compatible with the multiplication)
</td>
<td>arithmetic</td>
</tr>

<tr>
<td><code>Quotient</code></td>
<td><code>QuotientRing</code></td>
<td>ring of rational functions, 
    i.e. fractions of multivariate polynomials
    over any implemented unique factorization coefficient domains
</td>
<td>arithmetic
</td>
</tr>

<tr>
<td><code>Residue</code></td>
<td><code>ResidueRing</code></td>
<td>ring of polynomials modulo a given polynomial ideal,
    over any implemented coefficient ring
</td>
<td>arithmetic
</td>
</tr>

<tr>
<td><code>Local</code></td>
<td><code>LocalRing</code></td>
<td>ring of polynomials fractions localized with respect to a given polynomial ideal,
    over any implemented coefficient ring
</td>
<td>arithmetic
</td>
</tr>

<tr>
<td><code>Product</code></td>
<td><code>ProductRing</code></td>
<td>(finite) direct product of fields and rings 
    over any implemented coefficient ring
</td>
<td>arithmetic, idempotent elements
</td>
</tr>

<tr>
<td><code>GenVector</code></td>
<td><code>GenVectorModule</code></td>
<td>tuples (vectors) of any implemented 
    ring elements
</td>
<td>arithmetic, scalar product
</td>
</tr>

<tr>
<td><code>GenMatrix</code></td>
<td><code>GenMatrixModule</code></td>
<td>matrices of any implemented ring elements
</td>
<td>arithmetic, scalar product
</td>
</tr>

<tr>
<td><code>UnivPowerSeries</code></td>
<td><code>UnivPowerSeriesRing</code></td>
<td>ring of univariate power series 
    over any implemented coefficient ring
</td>
<td>arithmetic, gcd, evaluation, integration, fixed points</td>
</tr>

</table>

<p>
"Arithmetic" means implementation of the methods 
defined in the interface <code>RingElem</code>.
To be continued.
</p>


<h3>1.3. Algebraic algorithms overview</h3>

<p>
The following table contains an overview of 
implemented algebraic algorithms.
</p>

<table border="1" cellpadding="3" summary="JAS AA summary" >
<tr>
<td>class / interface</td>
<td>algorithm&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td>methods</td>
</tr>

<tr>
<td><code>Reduction</code>,
    <code>Reduction- Abstract</code>,
    <code>ReductionSeq</code>,
    <code>ReductionPar</code>,
    <code>PseudoReduction</code>
</td>
<td>Iterated subtraction of polynomials to eliminate terms from a given polynomial, 
    i.e. reduction of polynomial(s) wrt. a set of polynomials.
    Coefficients of polynomials must be from a field and for the 
    Pseudo* version from a ring with gcd.
    For *Par the list of polynomials can concurrently be modified.
</td>
<td>normalform,
    S-polynomial,
    criterions,
    extended normalform
</td>
</tr>

<tr>
<td><code>DReduction</code>
    <code>EReduction</code>
    <code>DReductionSeq</code>
    <code>EReductionSeq</code>
</td>
<td>Reduction of polynomial(s) wrt. a set of polynomials.
    Coefficients of polynomials must be from a 
    principial ideal domain (PID) or from an Euclidean domain.
</td>
<td>normalform,
    S-polynomial,
    G-polynomial,
    criterions,
    extended normalform
</td>
</tr>

<tr>
<td><code>SolvableReduction</code>
    <code>SolvableReduction- Abstract</code>
    <code>Solvable- ReductionSeq</code>
    <code>Solvable- ReductionPar</code>
</td>
<td>Left and right reduction of solvable polynomial(s) wrt. a 
    set of solvable polynomials.
    Coefficients of polynomials must be from a field.
</td>
<td>left/right normalform,
    left/right S-polynomial,
    criterions,
    extended left normalform
</td>
</tr>

<tr>
<td><code>RReduction</code>,
    <code>RPseudoReduction</code>,
    <code>RReductionSeq</code>,
    <code>RPseudoReductionSeq</code>
</td>
<td>Iterated subtraction of polynomials to eliminate terms from a given polynomial, 
    i.e. reduction of polynomial(s) wrt. a set of polynomials.
    Coefficients of polynomials must be from a regular ring and for the 
    Pseudo* version from a regular ring with gcd.
    Boolean closure and boolean remainder of polynomials.
</td>
<td>normalform,
    S-polynomial,
    <!--extended normalform,-->
    boolean closure
</td>
</tr>

<tr>
<td><code>CReductionSeq</code>,
    <code>Condition</code>,
    <code>ColorPolynomial</code>
</td>
<td>Iterated subtraction of polynomials to eliminate terms from a given polynomial, 
    i.e. reduction of polynomial(s) wrt. a set of polynomials.
    Coefficients of polynomials must be from a polynomial ring.
    Case distinction and determination of polynomaials with respect to conditions 
    leading to colored polynomials.
</td>
<td>normalform,
    S-polynomial,
    <!--extended normalform,-->
    color, determine
</td>
</tr>

<tr>
<td><code>GroebnerBase</code>,
    <code>GroebnerBase- Abstract</code>,
    <code>GroebnerBaseSeq</code>,
    <code>GroebnerBase- Parallel</code>,
    <code>GroebnerBase- Distributed</code>,
    <code>GroebnerBase- PseudoSeq</code>,
    etc.
</td>
<td>Buchberger algorithm to compute Groebner bases 
    of sets of polynomials.
    Coefficients of polynomials must be from a field.
    <code>*Parallel</code> is a multi-threaded and 
    <code>*Distributed</code> is a message passing implementation.  
    The <code>*Pseudo</code> version is for non-field coefficients.

</td>
<td>GB, isGB, extended GB, minimal GB
</td>
</tr>

<tr>
<td><code>DGroebnerBaseSeq</code>,
    <code>EGroebnerBaseSeq</code>
</td>
<td>Algorithm to compute D- and E- Groebner bases 
    of sets of polynomials.
    Coefficients of polynomials must be from a 
    principial ideal domain (PID) or from an Euclidean domain.
</td>
<td>GB, isGB, minimal GB
</td>
</tr>

<tr>
<td><code>SolvableGroebnerBase</code>,
    <code>SolvableGroebnerBase- Abstract</code>,
    <code>SolvableGroebnerBaseSeq</code>,
    <code>SolvableGroebnerBase- Parallel</code>
</td>
<td>Algorithm to compute left, right and two-sided Groebner bases 
    of sets of solvable polynomials.
    Coefficients of polynomials must be from a field.
    *Parallel is a multi-threaded implementation.  
</td>
<td>left, right, two-sided versions of GB, isGB, extended GB, minimal GB
</td>
</tr>

<tr>
<td><code>RGroebnerBaseSeq</code>,
    <code>RGroebnerBasePseudoSeq</code>
</td>
<td>Algorithm to compute Groebner bases in polynomial rings over regular rings.
    Coefficients of polynomials must be from a 
    product of fields or Euclidean domains.
</td>
<td>GB, isGB, minimal GB
</td>
</tr>

<tr>
<td><code>ComprehensiveGroebnerBaseSeq</code>,
    <code>ColoredSystem</code>
</td>
<td>Algorithm to compute comprehensive Groebner bases in polynomial rings over 
    parameter rings.
    Coefficients of polynomials must be from a polynomial ring.
    Computation is done via Groebner systems (lists of colored systems).
</td>
<td>GBsys, isGBsys, GB, isGB, minimalGB
</td>
</tr>

<tr>
<td><code>Syzygy</code>,
    <code>SyzygyAbstract</code>,
    <code>ModGroebnerBase</code>,
    <code>ModGroebnerBaseAbstract</code>,
</td>
<td>Algorithm to compute syzygies of lists of polynomials 
    or Groebner Bases, free resolutions.
    Groebner Bases for modules over polynomial rings.
    Coefficients of polynomials must be from a field.
</td>
<td>zeroRelations, isZeroRelation, 
    resolution, zeroRelationsArbitrary,
    GB, isGB
</td>
</tr>

<tr>
<td><code>SolvableSyzygy</code>,
    <code>Solvable- SyzygyAbstract</code>,
    <code>ModSolvable- GroebnerBase</code>,
    <code>ModSolvable- GroebnerBaseAbstract</code>,
</td>
<td>Algorithm to compute left and right syzygies of lists 
    of solvable polynomials or Groebner Bases, free left resolutions.
    Left, right and two-sided Groebner Bases for modules over solvable polynomial rings.
    Coefficients of polynomials must be from a field.
</td>
<td>leftZeroRelations, rightZeroRelations, 
    isLeftZeroRelation, isRightZeroRelation, 
    (left) resolution, zeroRelationsArbitrary,
    left, right, two-sided GB, isGB
</td>
</tr>

<tr>
<td><code>Ideal</code>
</td>
<td>Algorithms to compute sums, products, intersections, containment 
    and (infinite)quotients of polynomial ideals.
    Coefficients of polynomials must be from a field.
</td>
<td>sum, product, intersect, contains,
    quotient, infiniteQuotient, inverse modulo ideal
</td>
</tr>

<tr>
<td><code>GreatestCommonDivisor</code>,
    <code>GCDFactory</code>,
    <code>GreatestCommonDivisorAbstract</code>,
    <code>GreatestCommonDivisorSimple</code>,
    <code>GreatestCommonDivisorPrimitive</code>,
    <code>GreatestCommonDivisorSubres</code>,
    <code>GreatestCommonDivisorModular</code>,
    <code>GreatestCommonDivisorModEval</code>,
    <code>GCDProxy</code>
</td>
<td>Algorithms to compute greatest common divisors of polynomials 
    via different polynomial remainder sequences (PRS) and modular methods.
    Coefficients of polynomials must be from a unique factorization domain (UFD).
    <code>GCDFactory</code> helps with the optimal selection of an algorithm 
    and <code>GCDProxy</code> uses multi-threading to compute with 
    several implementations in parallel.
</td>
<td>gcd, lcm, content, primitivePart, 
    squarefreePart, squarefreeFactors, resultant
</td>
</tr>


</table>

<p>
</p>

<h2>2. Recursive ring element design</h2>

<p>
The next figure gives an overview of the central interfaces and classes.
The interface <code>RingElem</code> defines a <strong>recursive type</strong> 
which defines the functionality (see next section) of the 
polynomial coefficients and is also implemented by the 
polynomials itself. So polynomials can be taken as coefficients 
for other polynomials, thus defining a recursive polynomial ring structure.
</p>

<p>
Since the construction of constant ring elements has been difficult
in previuos designs, we separated the creational aspects of ring elements
into <strong>ring factories</strong> with sufficient context information. 
The minimal factory functionality is defined by the interface 
<code>RingFactory</code>.
Constructors for polynomial rings will then require factories for
the coefficients so that the construction of polynomials over these
coefficient rings poses no problem. 
The ring factories are additionaly required because of the 
Java generic type design. I.e. if <code>C</code> is a generic type name
it is not possible to construct an new object with <code>new C()</code>.
Even if this would be possible, one can not specify constructor signatures 
in Java interfaces, e.g. to construct a one or zero constant ring element.
Recursion is again achieved by using polynomial factories as 
coefficient factories in recursive polynomial rings.
Constructors for polynomials will always require 
a polynomial factory parameter which knows 
all details about the polynomial ring under consideration.
</p>

<p class="center" >
<a href="images/overview-recursive.png" 
   target="diagram"
   ><img src="images/overview-recursive.png" alt="JAS type overview" /></a>
<br />
UML diagram of JAS types
</p>


<h2>3. Coefficients and polynomials</h2>

<p>
We continue the discussion of the next layer of classes in the
the above figure.
</p>

<p>
Elementary <strong>coefficient classes</strong>, such as 
<code>BigRational</code> or <code>BigInteger</code>, implement both 
the <code>RingElem</code> and <code>RingFactory</code> interfaces. 
This is convenient, since these factories do not need further context 
information.
In the implementation of the interfaces the type parameter 
<code>C extends RingElem&lt;C&gt;</code> is simultaneously bound 
to the respective class, e.g. <code>BigRational</code>.
<strong>Coefficient objects</strong> can in most cases created directly 
via the respective class constructors, but also via the factory methods. 
E.g. the object representing the rational number 2 can be created by 
<code>new BigRational(2)</code> or by 
<code>fac = new BigRational()</code>, <code>fac.fromInteger(2)</code> and 
the object representing the rational number 1/2 can be created by 
<code>new BigRational(1,2)</code> or by 
<code>fac.parse("1/2")</code>.
</p>

<p>
<strong>Generic polynomials</strong> are implemented in the 
<code>GenPolynomial</code> class, which has a type parameter 
<code>C extends RingElem&lt;C&gt;</code> 
for the coefficient type. So all operations on coefficients required
in polynomial arithmetic and manipulation are guaranteed to exist by the 
<code>RingElem</code> interface. The constructors of the polynomials 
always require a matching polynomial factory. 
The <strong>generic polynomial factory</strong> is implemented in the class 
<code>GenPolynomialRing</code>, again with type parameter 
<code>C extends RingElem&lt;C&gt;</code> (not <code>RingFactory</code>).
The polynomial factory however implements the interface 
<code>RingFactory&lt;C extends RingElem&lt;C&gt;&gt;</code> so that 
it can also be used recursively.
The constructors for <code>GenPolynomialRing</code> require at least 
parameters for a coefficient factory and the number of variables 
of the polynomial ring.
</p>

<p>
Having generic polynomial and elementary coefficient implementations 
one can attempt to construct <strong>polynomial objects</strong>. 
The type is first created by binding the type parameter 
<code>C extends RingElem&lt;C&gt;</code> to the desired coefficient type, 
e.g. <code>BigRational</code>. So we arrive at the type
<code>GenPolynomial&lt;BigRational&gt;</code>.
Polynomial objects are then created via the respective polynomial factory
of type <code>GenPolynomialRing&lt;BigRational&gt;</code>, 
which is created by binding the generic coefficient type of the 
generic polynomial factory to the desired coefficient type, 
e.g. <code>BigRational</code>.
A <strong>polynomial factory object</strong> is created from a 
coefficient factory object and the number of variables in the 
polynomial ring as usual with the <code>new</code> operator via one 
of its constructors.
Given an object <code>coFac</code> of type <code>BigRational</code>,
e.g. created with <code>new BigRational()</code>, a polynomial factory
object <code>pfac</code> of the above described type could be created by 
<code>new GenPolynomialRing&lt;BigRational&gt;(coFac,5)</code>.
I.e. we specified a polynomial ring with 5 variables over 
the rational numbers.
A polynomial object <code>p</code> of the above described type can then
be created by any method defined in <code>RingFactory</code>, 
e.g. by <code>pfac.getONE()</code>, 
<code>pfac.fromInteger(1)</code>, <code>pfac.random(3)</code>
or <code>pfac.parse("(1)")</code>.
</p>

<p>
Since <code>GenPolynomial</code> itself implements the 
<code>RingElem</code> interface, they can also be used recursively
as coefficients. 
We continue the polynomial example and are going to use polynomials over
the rational numbers as coefficients of a new polynomial. 
The type is then 
<code>GenPolynomial&lt;GenPolynomial&lt;BigRational&gt;&gt;</code>
and the polynomial factory has type
<code>GenPolynomial<b>Ring</b>&lt;GenPolynomial&lt;BigRational&gt;&gt;</code>.
Using the polynomial coefficient factory <code>pfac</code> from above
a recursive polynomial factory <code>rfac</code> could be created by 
<code>new GenPolynomialRing&lt;GenPolynomial&lt;BigRational&gt;&gt;(pfac,3)</code>.
The creation of a recursive polynomial object <code>r</code> of the 
above described type is then as a easy as before
e.g. by <code>rfac.getONE()</code>, 
<code>rfac.fromInteger(1)</code> or <code>rfac.random(3)</code>.
</p>


<h2>4. Solvable polynomials</h2>

<p>
We turn now to the last layer of classes in the the above figure.
</p>

<p>
The generic polynomials are intended as super class for further 
types of polynomial rings. As one example we take so called 
<strong>solvable polynomials</strong>, which are like normal polynomials 
but are equipped with a new non-commutative multiplication. 
They are implemented in the class <code>GenSolvablePolynomial</code> 
which extends <code>GenPolynomial</code> and inherits all methods 
except <code>clone()</code> and <code>multiply()</code>.
The class also has a type parameter <code>C extends RingElem&lt;C&gt;</code> 
for the coefficient type.
Note, that the inherited methods are in fact creating solvable polynomials 
since they employ the solvable polynomial factory for the creation of any
new polynomial internally. Only the formal method return type is that 
of <code>GenPolynomial</code>, the run-time type is 
<code>GenSolvablePolynomial</code> to which they can be casted at any time.
The <strong>factory for solvable polynomials</strong> is implemented 
by the class <code>GenSolvablePolynomialRing</code> which also 
extends the generic polynomial factory. So this factory can also be used 
in the constructors of <code>GenPolynomial</code> via <code>super()</code> 
to produce in fact solvable polynomials internally. The data structure 
is enhanced by a table of non-commutative relations defining the 
new multiplication. The constructors delegate most things to the 
corresponding super class constructors and additionally have a 
parameter for the <code>RelationTable</code> to be used.
Also the methods delegate the work to the respective super class methods 
where possible and then handle the non-commutative multiplication relations 
separately.
</p>

<p>
The construction of <strong>solvable polynomial objects</strong>
follows directly that of polynomial objects.
The type is created by binding the type parameter 
<code>C extends RingElem&lt;C&gt;</code> to the desired coefficient type, 
e.g. <code>BigRational</code>. So we have the type
<code>GenSolvablePolynomial&lt;BigRational&gt;</code>.
Solvable polynomial objects are then created via the respective 
solvable polynomial factory of type 
<code>GenSolvablePolynomialRing&lt;BigRational&gt;</code>, 
which is created by binding the generic coefficient type of the 
generic polynomial factory to the desired coefficient type, 
e.g. <code>BigRational</code>.
A <strong>solvable polynomial factory object</strong> is created from a 
coefficient factory object, the number of variables in the 
polynomial ring and a table containing the defining non-commutative relations
as usual with the <code>new</code> operator via one of its constructors.
Given an object <code>coFac</code> of type <code>BigRational</code>
as before, a polynomial factory object <code>spfac</code> 
of the above described type could be created by 
<code>new GenSolvablePolynomialRing&lt;BigRational&gt;(coFac,5)</code>.
I.e. we specified a polynomial ring with 5 variables over 
the rational numbers with no commutator relations.
A solvable polynomial object <code>p</code> of the above described type 
can then be created by any method defined in <code>RingFactory</code>, 
e.g. by <code>spfac.getONE()</code>, 
<code>spfac.fromInteger(1)</code>, <code>spfac.random(3)</code>
or <code>spfac.parse("(1)")</code>.
Some care is needed to create <code>RelationTable</code> objects 
since its constructor requires the solvable polynomial ring which 
is under construction as parameter. It is most convenient to first
create a <code>GenSolvablePolynomialRing</code> with an 
empty relation table and then to add the defining relations.
</p>


<h2>5. Ring element and factory functionality</h2>

<p>
The following sections and the next figure gives an overview 
of the functionality of the main interfaces and polynomial classes.
</p>

<p>
The <code>RingElem</code> interface has a generic type parameter 
<code>C</code> which is constrained to a type with the same functionality
<code>C extends RingElem&lt;C&gt;</code>.
It defines the usual methods required for ring arithmetic such as
<code>C sum(C S); C subtract(C S); C negate(); C abs();
      C multiply(C S); C divide(C S); C remainder(C S); C inverse();
</code>
Although the actual ring may not have inverses for every element
or some division algorithm we have included these methods in the definition.
In a case where there is no such function, the implementation may 
deliberately throw a <code>RuntimeException</code> or choose some 
other meaningful element to return.
The method <code>isUnit()</code> can be used to check if an element 
is invertible.
</p>
<p>
Besides the arithmetic method there are following testing methods
<code>boolean isZERO(); boolean isONE(); boolean isUnit();
    int signum();
    boolean equals(Object b); int hashCode(); int compareTo(C b); 
</code>
The first three test if the element is 0, 1 or a unit in the respective ring.
The <code>signum()</code> method defines the sign of the element (in case 
of an ordered ring).
<code>equals()</code>, <code>hashCode()</code> and <code>compareTo()</code> 
are required to keep Javas object machinery working in our sense. 
They are used when an element is put into a Java collection class, 
e.g. <code>Set</code>, <code>Map</code> or <code>SortedMap</code>.
The last method <code>C clone()</code> can be used to obtain a copy of the
actual element. As creational method one should better use the 
method <code>C copy(C a)</code> from the ring factory, but in Java 
it is more convenient to use the <code>clone()</code> method.
</p>

<p>
As mentioned before, the creational aspects of rings are separated 
into a ring factory. A ring factory is intended to store all context
information known or required for a specific ring. 
Every ring element should also know its ring factory, so all
constructors of ring element implementations require a parameter 
for the corresponding ring factory. Unfortunately constructors 
and their signature can not be specified in a Java interface.
The <code>RingFactory</code> interface also has a generic type parameter 
<code>C</code> which is constrained to a type with the ring element 
functionality <code>C extends RingElem&lt;C&gt;</code>.
The defined methods are 
<code>C getZERO(); C getONE();
      C fromInteger(long a); C fromInteger(java.math.BigInteger a);
      C random(int n); C copy(C c);
      C parse(String s); C parse(Reader r);
</code>
The first two create 0 and 1 of the ring.
The second two are used to embed a natural number into the ring 
and create the corresponding ring element.
The <code>copy()</code> method was intended as the main means to 
obtain a copy of a ring element, but it is now no more used in our 
implmentation. Instead the <code>clone()</code> method is used from 
the ring element interface.
The <code>random(int n)</code> method creates a random element of the 
respective ring. The parameter <code>n</code> specifies an appropriate 
maximal size for the created element. In case of coefficients it
usually means the maximal bit-length of the element, in case of 
polynomials it influences the coefficient size and the degrees. 
For polynomials there are <code>random()</code> methods with more 
parameters.
The two methods 
<code>C parse(String s)</code> and <code>C parse(Reader r)</code> 
create a ring element from some external string representation.
For coefficients this is mostly implemented directly and for 
polynomials the class <code>GenPolynomialTokenizer</code> is 
employed internally.
In the current implementation the external representation of 
coefficients may never contain white space and must always start 
with a digit.
In the future the ring factory will be enhanced by methods that
test if the ring is commutative, associative or has some 
other important property or the value of a property, 
e.g. is an euclidean ring, is a field, an integal domain, 
a uniqe factorization domain, its characteristic or if it is noetherian. 
</p>

<p class="center" >
<a href="images/overview-methods.png" 
   target="diagram"
   ><img src="images/overview-methods.png" alt="JAS type functionality" /></a>
<br />
UML diagram of JAS type functionality
</p>


<h2>6. Polynomial and polynomial factory functionality</h2>

<p>
We continue the discussion of the above figure 
with the generic polynomial and factory classes.
</p>

<p>
The <code>GenPolynomial</code> class has a generic type parameter 
<code>C</code> which is constrained to a type with the functionality
of ring elements <code>C extends RingElem&lt;C&gt;</code>.
Further the class implements a <code>RingElem</code> over itself
<code>RingElem&lt;GenPolynomial&lt;C&gt;&gt;</code> 
so that it can be used for the coefficients of an other polynomial ring.
The functionality of the ring element methods has already been explained 
in the previous section. 
There are two public and one protected constructors, each requires
at least a ring factory parameter <code>GenPolynomialRing&lt;C&gt; r</code>.
The first creates a zero polynomial
<code>GenPolynomial(. r)</code>,
the second creates a polynomial of one monomial with given coefficient 
and exponent tuple
<code>GenPolynomial(. r, C c, ExpVector e)</code>, 
the third creates a polynomial from the internal sorted map of an 
other polynomial
<code>GenPolynomial(. r, SortedMap&lt;ExpVector,C&gt; v)</code>.
Further there are methods to access parts of the polynomial 
like leading term, leading coefficient 
(still called leading base coefficient from the Aldes/SAC-2 tradition)
and leading monomial.
The <code>toString()</code> method creates as usual a string representation 
of the polynomials consisting of exponent tuples and coefficients. 
One variant of it takes an array of variable names and creates a string
consisting of coefficients and products of powers of variables.
The method <code>extend()</code> is used to embed the polynomial into the 
'bigger' polynomial ring specified in the first parameter. 
The embeded polynomial can also be multiplied by a power of a variable.
The <code>contract()</code> method returns a map of exponents and 
coefficients. The coefficients are polynomials belonging to the 
'smaller' polynomial ring specified in the first parameter. 
If the polynomial actually belongs to the smaller polynomial ring 
the map will contain only one pair, mapping the zero exponent vector
to the polynomial with variables removed.
A last group of methods computes (extended) greatest common divisors.
They work correct for univariate polynomials over a field but not 
for arbitrary multivatiate polynomials. These methods will be moved
to a new separate class in the future.
</p>

<p>
The <code>GenPolynomialRing</code> class has a generic type parameter 
<code>C</code> which is constrained to a type with the functionality
of ring elements <code>C extends RingElem&lt;C&gt;</code>.
Further the class implements a <code>RingFactory</code> over 
<code>GenPolynomial&lt;C&gt;</code> so that it can be used as
coefficient factory of a different polynomial ring.
The constructors require at least a factory for the coefficents as
first parameter of type <code>RingFactory&lt;C&gt;</code>
and the number of variables in the second parameter.
A third parameter can optionally specify a <code>TermOrder</code> 
and a fourth parameter can specify the names for the variables
of the polynomial ring.
Besides the methods required by the <code>RingFactory</code>
interface there are additional <code>random()</code> methods
which provide more control over the creation of random polynomials. 
They have the following parameters: 
the bitsize of random coefficients to be used in the 
<code>random()</code> method of the coefficient factory,
the number of terms (i.e. the length of the polynomial), 
the maximal degree in each variable
and the density of nozero exponents, i.e. the ratio of nonzero to 
zero exponents.
The <code>toString()</code> method creates a string representation 
of the polynomial ring consisting of the coefficient factory string 
representation, the tuple of variable names and the string representation 
of the term order. 
The <code>extend()</code> and <code>contract()</code> methods
create 'bigger' respectively 'smaller' polynomial rings. 
Both methods take a parameter of how many variables are to be added 
or removed form the actual polynomial ring.
<code>extend()</code> will setup an elimination term order consisting 
of two times the actual term order when ever possible.
</p>


<h2>7. Solvable polynomial and solvable polynomial factory functionality</h2>

<p>
We continue the discussion of the above figure 
with the generic solvable polynomial and factory classes.
</p>

<p>
The <code>GenSolvablePolynomial</code> class has a generic type parameter 
<code>C</code> which is constrained to a type with the functionality
of ring elements <code>C extends RingElem&lt;C&gt;</code>.
The class extends the <code>GenPolynomial</code> class. It inherits 
all additive functionality and overwrites the multiplicative 
functionality with a new non-commutative multiplication method.
Unfortunately it <em>cannot</em> implement a <code>RingElem</code> 
over itself <code>RingElem&lt;GenSolvablePolynomial&lt;C&gt;&gt;</code> 
but can only inherit the implementation of 
<code>RingElem&lt;GenPolynomial&lt;C&gt;&gt;</code> from its super class.
By this limitation a solvable polynomial can still be used as 
coefficent in another polynomial, but only with the type of its super 
class. The limitation comes form the erasure of template parameters in 
<code>RingElem&lt;...&gt;</code> to <code>RingElem</code> for the 
code generated. I.e. the generic interfaces become the same after
type erasure and it is not allowed to implement the same interface twice.
There are two public and one protected constructors as in the super class.
Each requires at least a ring factory parameter 
<code>GenSolvablePolynomialRing&lt;C&gt; r</code> 
which is stored in a variable of this type shadowing the variable 
with the same name of the super factory type. The rest of the 
initialization work is delegated to the super class constructor.
</p>

<p>
The <code>GenSolvablePolynomialRing</code> class has a generic type parameter 
<code>C</code> which is constrained to a type with the functionality
of ring elements <code>C extends RingElem&lt;C&gt;</code>.
The class extends the <code>GenPolynomialRing</code> class. 
It overwrites most methods to implement the new non-commutative 
methods.
Also this class cannot implement a <code>RingFactory</code> over 
<code>GenSolvablePolynomial&lt;C&gt;</code>. It only implements 
<code>RingFactory</code> over <code>GenPolynomial&lt;C&gt;</code>
by inheritance by the same reason of type erasure as above.
But it can be used as coefficient factory with the type of its super class
for a different polynomial ring.
One part of the constructors just restate the super class constructors
with the actual solvable type. A solvable polynomial ring however 
must know how to perform the non-commutative multiplication. 
To this end a data structure with the respective commutator relations 
is required. It is implemented in the <code>RelationTable</code> class.
The other part of the constructors additionaly takes a parameter of type
<code>RelationTable</code> to set the initial commutator relation table.
Some care is needed to create relation tables and solvable polynomial
factories since the relation table requires a solvable polynomial
factory as parameter in the constructor. So it is most advisable to 
create a solvable polynomial factory object with empty relation table
and to fill it with commutator relations after the constructor is 
completed but before the factory will be used.
There is also a new method <code>isAssociative()</code> which tries
to check if the commutator relations indeed define an associative 
algebra. This method should be extracted to the <code>RingFactory</code>
interface together with a method <code>isCommutative()</code>, 
since both are of general importance and not always fulfilled 
in our rings. E.g. <code>BigQuaternion</code> is not commutative 
and so is a polynomial ring over these coefficents is not commutative.
The same applies to associativity and the (not jet existing) class
<code>BigOctonion</code>.
</p>

<p>
This concludes the discussion of the main interfaces and classes 
of the Java algebra system.
</p>


<!--
<code></code> 
<p>
</p>
<p>
</p>
<pre>
</pre>
-->

<p><!--a href="README" target="readme" >README</a-->
</p>

    <hr />
<address><a href="mailto:kredel at rz.uni-mannheim.de">Heinz Kredel</a></address>
<p>
<!-- Created: Sat Mar 11 10:51:36 CET 2006 -->
<!-- hhmts start -->
Last modified: Thu Oct  2 22:06:32 CEST 2008
<!-- hhmts end -->
</p>
<!--p align="right" >
$Id: design.html 2158 2008-10-02 20:08:05Z kredel $
</p-->
  </body>
</html>
